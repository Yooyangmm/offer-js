# 剑指Offer14-II.剪绳子II

Medium

### 题目：

​	给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m - 1]` 。请问 `k[0]*k[1]*...*k[m - 1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

#### 示例1：

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

#### 示例2：

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```



### 解答：

#### 解法：贪心

​	根据数学规律可以推出，将绳子尽可能多的分成长度为 `3` 的每一段，并且最终分出来的结果只能是 `3` 或者 `2` ，这样可以让每一段的乘积尽可能大。

​	如果将一条长度为 `n` 的绳子尽可能多的分成每一段长度 `3` ，那么最后一段（设为 `b` ）三种可能：

- ​	`b === 0` ：说明绳子可以等分长度为 `3` 的每一段，把所有 `3` 相乘即可取得最大值
- ​	`b === 1` ：说明最后一段长度都是 `1` （可能是3 3 3 3 3 3 1），把最后两两端的 `3 x 1` 拿出来拆成 `2 x 2` 可以使得乘积更大。
- ​	`b === 2` ：说明最后一段长度都是 `2` （可能是3 3 3 3 3 3 2），这时候就不用拆了，直接全部相乘即可。

```js
/**
 * @param {number} n
 * @return {number}
 */
var cuttingRope = function(n) {
    if (n < 4) return n - 1
    let res = 1, round = Math.floor(n / 3)
    const b = n % 3, MOD = 1000000007
    while (--round) { // 少乘一次
        res = res * 3 % MOD
    }
    if (b === 0) {
        return res * 3 % MOD
    } else if (b === 1) {
        return res * 2 * 2 % MOD
    } else {
        return res * 3 * 2 % MOD
    }
};
```

